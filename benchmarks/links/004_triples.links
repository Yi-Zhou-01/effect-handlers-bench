sig choose : Comp(Bool, {Choose:(()) {}-> Bool|_})
fun choose() {do Choose(())}

sig fail : Comp(a, {Failure:(()) {}-> Zero|_})
fun fail() {switch (do Failure(())) { }}

sig choice : (Int) {Choose:(()) {}-> Bool,Failure:(()) {}-> Zero|a}~> Int
fun choice(n) {
    if (n < 1) {fail() }
    else if (choose()) { n }
    else { choice(n-1) }
}

sig triple : (Int, Int) -a-> () {Choose:(()) {}-> Bool,Failure:(()) {}-> Zero|b}~> (Int, Int, Int)
fun triple(n,s)(){
    var i = choice(n);
    var j = choice(i-1);
    var k = choice(j-1);
    if (i+j+k == s) {((i,j,k))}
    else {fail()}
}

sig hash_triple : (() -a-> (Int, Int, Int)) -b-> () -a-> Int
fun hash_triple(m)(){
    var (a,b,c) = m (); 
    mod((53 * a + 2809 * b + 148877 * c), 1000000007)
}

sig handler : (() {Choose:(()) {}-> Bool,Failure:(()) {}-> a::Any|b}~> Int) {Choose{c},Failure{d}|b}~> Int
fun handler(m) {
    handle(m()) {
        case Return(x) -> x
        case Choose((), k) -> mod((k(true) + k(false)), 1000000007)
        case Failure((), k) -> 0
    }
}

sig main : () {Choose{a},Failure{b}|c}~> ()
fun main(){
    var n = stringToInt(getArgs() !! 0);
    var s = stringToInt(getArgs() !! 1);
    var sum = handler(hash_triple(triple(n, s)));
    println(intToString(sum))
}

main()